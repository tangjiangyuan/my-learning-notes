### 消息可靠性问题

![image-20250914102248633](./assets/image-20250914102248633.png)



## 一、发送者的可靠性

### 1、发送者重连

#### 1.1、介绍

![image-20250914102805990](./assets/image-20250914102805990.png)

![image-20250914103223302](./assets/image-20250914103223302.png)



### 2、发送者确认

#### 2.1、介绍

![image-20250914103957854](./assets/image-20250914103957854.png)

#### 2.2、SpringAMQP实现发送者确认

![image-20250914104445264](./assets/image-20250914104445264.png)

![image-20250914104720022](./assets/image-20250914104720022.png)

![image-20250914105632965](./assets/image-20250914105632965.png)

#### 2.3、演示

![image-20250914111804877](./assets/image-20250914111804877.png)

![image-20250914110728385](./assets/image-20250914110728385.png)

![image-20250914111734128](./assets/image-20250914111734128.png)

![image-20250914112242300](./assets/image-20250914112242300.png)

![image-20250914111941092](./assets/image-20250914111941092.png)

```
由于开启消息确认，会影响系统性能，一般建议不开启；除非有特殊场景必须使用
```



## 二、MQ的可靠性

### 1.、分析

![image-20250914121250188](./assets/image-20250914121250188.png)

### 2、数据持久化

#### 2.1、分析

![image-20250914145418013](./assets/image-20250914145418013.png)

#### 2.2、演示

![image-20250914151001594](./assets/image-20250914151001594.png)

![image-20250914151221544](./assets/image-20250914151221544.png)

![image-20250914150920854](./assets/image-20250914150920854.png)



### 3、Lazy Queue

#### 3.1、介绍

![image-20250914203346249](./assets/image-20250914203346249.png)



#### 3.2、配置LazyQueue

##### 3.2.1、控制台

![image-20250914203445962](./assets/image-20250914203445962.png)

##### 3.2.2、代码实现

![image-20250914203620742](./assets/image-20250914203620742.png)

##### 3.2.3、演示

![image-20250914204117306](./assets/image-20250914204117306.png)

![image-20250914204130857](./assets/image-20250914204130857.png)

![image-20250914203831462](./assets/image-20250914203831462.png)

### 4、比较

![image-20250914204244826](./assets/image-20250914204244826.png)

```
根据两种方式的吞吐量来说，一般选择LazyQueue方式，不管是持久化还是非持久化的数据都会写到磁盘。速度快、性能强、并发能力好。
```

### 5、总结&面试题

![image-20250914204602709](./assets/image-20250914204602709.png)



## 三、消费者的可靠性

### 1、消费者确认机制

#### 1.1、介绍

![image-20250914205814969](./assets/image-20250914205814969.png)

#### 1.2、配置

![image-20250914210106289](./assets/image-20250914210106289.png)

#### 1.3、演示

![image-20250914210354970](./assets/image-20250914210354970.png)

![image-20250914210854010](./assets/image-20250914210854010.png)

```
如果收到消息后，队列会处于uack状态(未确认状态)，直到消费者返回ack，队列才会删除消息；
如果收到消息后，业务逻辑抛出消息转换异常，MQ会自动帮消费者返回reject，队列直接删除消息。
```



### 2、失败重试机制

#### 2.1、介绍&配置

![image-20250914211646844](./assets/image-20250914211646844.png)

#### 2.2、演示

![image-20250914212219998](./assets/image-20250914212219998.png)

#### 2.3、失败消息处理策略

![image-20250914212908166](./assets/image-20250914212908166.png)

#### 2.4、配置

![image-20250914213048552](./assets/image-20250914213048552.png)

#### 2.5、演示

![image-20250914214202354](./assets/image-20250914214202354.png)

![image-20250914214113324](./assets/image-20250914214113324.png)

![image-20250914214249106](./assets/image-20250914214249106.png)

#### 2.6、小结

![image-20250914214409824](./assets/image-20250914214409824.png)



### 3、业务幂等性

#### 3.1、介绍

![image-20250915090315665](./assets/image-20250915090315665.png)

#### 3.2、唯一ID

![image-20250915090859776](./assets/image-20250915090859776.png)

![image-20250915091351990](./assets/image-20250915091351990.png)

![image-20250915091258009](./assets/image-20250915091258009.png)

![image-20250915092046737](./assets/image-20250915092046737.png)

===弊端

```
对原代码有浸入，在原业务的基础上每次获取消息时都要去数据库查找消息ID，并进行健壮性判断。不推荐该方案。
```



#### 3.3、业务判断

![image-20250915093214832](./assets/image-20250915093214832.png)

![image-20250915093404059](./assets/image-20250915093404059.png)

![image-20250915094430281](./assets/image-20250915094430281.png)

#### 3.4、总结 & 面试题

![image-20250915094910723](./assets/image-20250915094910723.png)



## 四、延迟消息

```
因为谁也无法保证网络没有问题，因此还需要一些兜底方案
```

### 1、介绍

![image-20250915095911750](./assets/image-20250915095911750.png)

### 2、死信交换机

#### 2.1、介绍

![image-20250915100735349](./assets/image-20250915100735349.png)

#### 2.2、演示

![image-20250915103542885](./assets/image-20250915103542885.png)

![image-20250915103605664](./assets/image-20250915103605664.png)

![image-20250915103703458](./assets/image-20250915103703458.png)



### 3、延迟消息插件

#### 3.1、介绍

![image-20250915110459751](./assets/image-20250915110459751.png)

![image-20250915111635487](./assets/image-20250915111635487.png)

![image-20250915111723186](./assets/image-20250915111723186.png)

#### 3.2、演示

下载插件

![image-20250915111351809](./assets/image-20250915111351809.png)

导入容器中

![image-20250915111132295](./assets/image-20250915111132295.png)

安装插件

```shell
docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange
```

![image-20250915112737722](./assets/image-20250915112737722.png)

![image-20250915112753594](./assets/image-20250915112753594.png)

![image-20250915112826188](./assets/image-20250915112826188.png)

```
注意：消息的延迟依赖CPU的支持，因此要避免同一时刻大量数据进行延迟，给CPU造成影响。
```



### 4、取消超时订单

#### 4.1、分析

![image-20250915140806621](./assets/image-20250915140806621.png)

#### 4.2、演示

![image-20250915141513246](./assets/image-20250915141513246.png)

![image-20250915142406345](./assets/image-20250915142406345.png)

![image-20250915143755681](./assets/image-20250915143755681.png)

![image-20250915143637242](./assets/image-20250915143637242.png)

![image-20250915145116076](./assets/image-20250915145116076.png)

![image-20250915160504702](./assets/image-20250915160504702.png)