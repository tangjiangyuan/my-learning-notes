## day02、

![image-20250801200227121](D:\软件工程\Java\java-basic\day02\assets\image-20250801200227121.png)

## 一、变量

### 1、定义

变量就是内存中存储空间，空间中存储着经常发生变化的数据。

### 2、格式

数据类型 变量名 = 数据值;

### 3、DeBug工具

是提供给程序员使用的**程序调试工具**，它可以用于**查看程序的执行流程**，也可以用于**追踪程序执行过程来调试程序**。

### 4、DeBug调试

又被称为断点调试，断点就是一个标记，告诉DeBug从标记的地方开始查看。

如何添加断点：鼠标左击代码行

如何取消断点：再次点击代码行

![image-20250801201018407](D:\软件工程\Java\java-basic\day02\assets\image-20250801201018407.png)

通过添加断点，来分段调试代码，添加多个断点，来设置调试的代码范围。

### 5、变量的注意事项

（1）变量名不允许重复定义；

（2）一条语句可以定义多个变量，中间使用逗号隔开；

（3）变量在使用之前，必须完成赋值（成员变量有默认值，此处指局部变量）

## 二、标识符

### 1、定义

就是给类、变量和方法起名字的符号。

### 2、命名规则

（1）由数字、字母、美元符和下划线组成；

（2）不能以数字开头；

（3）不能是关键字；

（4）区分大小写。

### 3、命名规范

#### 3.1、小驼峰命名法 -- 变量、方法

（1）标识符是一个单词的时候，所有字母小写；name

（2）标识符由多个单词组成的时候，首个单词的首字母小写，其它单词的首字母大写。firstName

#### 3.2、大驼峰命名法 -- 类、接口

（1）标识符是一个单词的时候，首字母大写；User

（2）标识符由多个单词组成的时候，所有单词的首字母大写。GoodStudent

## 三、数据类型

### 1、基本数据类型

![](D:\软件工程\Java\java-basic\day02\assets\image-20230222151326600.png)

说明：e+38表示乘以10的38次方，e-45表示乘以10的负45次方

#### 1.1、字节

（1）**比特位 ：**bit ，是计算机**存储信息的最小单位**，存放一位二进制数，即 `0 或 1`

（2）**字节：**byte，是计算机**分配内存的最小单位**，通常用大写字母“B”表示，一个字节包含了8个比特位，即：`1byte = 8bits`

#### 1.2、计算机存储容量的单位

- 1KB (Kilobyte 千字节) = 1024B，其中1024=2^10 ( 2 的10次方)

- 1MB (Megabyte 兆字节 简称“兆”) = 1024KB

- 1GB (Gigabyte 吉字节 又称“千兆”) = 1024MB

- 1TB (Trillionbyte 万亿字节 太字节) = 1024GB

### 2、引用数据类型

数组、类、接口、String、集合

## 四、Scanner 键盘录入

键盘录入可以使程序中使用的数据更加灵活

![image-20250801202651511](D:\软件工程\Java\java-basic\day02\assets\image-20250801202651511.png)

![image-20250801202657893](D:\软件工程\Java\java-basic\day02\assets\image-20250801202657893.png)

## 五、运算符

### 1、引言

#### 1.1、运算符

对字面量或者变量进行操作的符号。

#### 1.2、表达式

用**运算符**把字面量或者变量连接起来的**符合Java语法的式子**，就可以称为表达式。不同运算符连接的表达式体现的是不同类型的表达式。

### 2、算数运算符

![image-20250801203255205](D:\软件工程\Java\java-basic\day02\assets\image-20250801203255205.png)

案例：

![image-20250801203312869](D:\软件工程\Java\java-basic\day02\assets\image-20250801203312869.png)

```java
public class Test01 {
  public static void main(String[] args) {
    getNum();
  }
  public static void getNum() {
    Scanner sc = new Scanner(System.in);
    System.out.println("请输入一个三位数:");
    int num = sc.nextInt();
    int ge = num % 10;
    int shi = num / 10 % 10;
    int bai = num / 100;
    sc.close();
    System.out.println("个位:" + ge);
    System.out.println("十位:" + shi);
    System.out.println("百位:" + bai);
  }
}
```

字符串拼接操作

![image-20250801203940951](D:\软件工程\Java\java-basic\day02\assets\image-20250801203940951.png)

### 3、自增自减运算符

![image-20250801203954190](D:\软件工程\Java\java-basic\day02\assets\image-20250801203954190.png)

![image-20250801204000033](D:\软件工程\Java\java-basic\day02\assets\image-20250801204000033.png)

```java
/*
        自增自减运算符：
        ++
        --
        int a = 10;
        ++a;
        System.out.println(a); // 11
        ---------------------------
        ++在前：先自增，再取值
        int a = 10;
        int b = ++a;
        System.out.println(a);  // 11
        System.out.println(b);  // 11
        ---------------------------
        ++在后：先取值，再自增
        int a = 10;
        int b = a++;
        System.out.println(a);  // 11
        System.out.println(b);  // 10
     */
    public static void main(String[] args) {
        int a = 10;
        a++;
        System.out.println(a); // 11
    }
```

案例

```java
 public static void main(String[] args) {
        int x = 10;
        int y = x++;// y=10,x=11
        int z = ++y;// x=11,z=11,y=11
        System.out.println("x=" + x);
        System.out.println("y=" + y);
        System.out.println("z=" + z);

        System.out.println("-----------------------");

        int a = 3;
        int b = (++a) + (a++) + (a * 10); // 58                                       
        System.out.println("a=" + a);
        System.out.println("b=" + b);
    }
```

### 4、类型转换

#### 4.1、隐式转换

（1）概念：把一个**取值范围小**的数值或者变量，赋值给一个**取值范围大**的变量。

```java
int a = 10;
double b = a;
System.out.println(b);
```

（2）取值范围排序（从小到大）：

byte -> short -> int -> long -> float -> double 

（3）问题：float占用了4个字节，为什么比占用了8个字节的long大？

float的取值范围long的大。

```java
long c = 123L;
float d = c;
```

（4）运算中的隐式转换：取值范围小的数据和取值范围大的数据进行运算时，小的会提升为大的，再运算。

```java
int e = 10;
double f = 20.0;
double g = e + f;
```

==== 注意：byte、short、char三种数据类型在运算时，都会提升至 int再运算

#### 4.2、强制转换

（1）概念：把一个**取值范围大**的数值或者变量，赋值给另一个**取值范围小**的变量时，不允许直接赋值，需要加入强制转换。有可能会造成精度损失！

（2）格式：

目标数据类型 变量名 = (目标数据类型) 被强制转换的数据；

```java
double a = 12.3;
int b = (int) a;
```

特殊：

```java
int num1 = 130;
byte num2 = (byte) num1;
System.out.println(num2); // -126,因为byte的取值范围是-128~127
```

#### 4.3、进制

##### 4.3.1、概念

进制就是进位制，是人们规定的一种进位方法，二进制逢2进1，八进制是逢8进1，十进制逢10进1，十六进制逢16进1。

##### 4.3.2、不同进制形式

| 二进制   | 0b\|B开头，由0和1组成              |
| -------- | ---------------------------------- |
| 八进制   | 0开头，由数字0~7组成               |
| 十进制   | 常见正数，0~9                      |
| 十六进制 | 0x或0X开头，由数字0~9和字母a~f组成 |

##### 4.3.3、进制转换

（1）**任意进制转 10进制** ：结果 = 系数*基数的权次幂相加

系数：每一位上的数据

基数：X进制，基数就是X

权：最右边那位对应0，每左移一位加1

演示：

```java
// 97：系数为9和7，基数为10，权是0和1
97: 7*10^0 + 9*10^1 = 7 + 90 = 97
    
0b01100001: 1*2^0 + 0*2^1 + 0*2^2 + 0*2^3 + 0*2^4 + 1*2^5 + 1*2^6 
    = 1 + 32 + 64 = 97

0141：1*8^0 + 4*8^1 + 1*8^2 = 1 + 32 + 64 = 97 

// 0x61：系数为6和1，基数为16，权是0和1
0x61：1*16^0 + 6*16^1 = 1 + 96 = 97
```

（2）十进制转换为其它进制

==除积倒取余==，具体计算过程如下：

![](D:\软件工程\Java\java-basic\day02\assets\image-20230222231844606.png)

（3）十进制转二进制的快速转换：八四二一快速转换法

![image-20250801211437530](D:\软件工程\Java\java-basic\day02\assets\image-20250801211437530.png)

（4）二进制转换为8、16进制

- **2进制转化为8进制**

​		从最低位开始，每3位分一组，不足3位的话高位补0

​		将得到的数字组合到一起，最前面以0开头

演示：

```java
//定义变量
byte b = 126;

//获取其二进制形式
// 126 = 127 - 1 或 64 + 32 + 16 + 8 + 4 + 2
// 	0b 0111 1110 
//2进制 -> 8进制   
//a.从最低位开始，每3位分一组，不足3位则高位补0
//	001 111 110
//	 1   7   6
//b.最后组合到一起，最前面以0开头
//结果：0176
byte b2 = 0176;
System.out.println(b == b2);
```

- **2进制转换为16进制**

​		从最低位开始，每4位分一组，不足4位的话高位补0

​		将得到的数字组合到一起，最前面以0x开头

演示：

```java
//定义变量
byte b = 126;

//二进制形式：0b 0111 1110 
//2进制 -> 16进制   
//a.从最低位开始，每4位分一组，不足4位则高位补0
//	0000 0111 1110
//	  0    7   e(14)		其中a:10 b:11 c:12 d:13 e:14 f:15
//b.最后组合到一起，最前面以0x开头
//结果：0x07e
byte b2 = 0x07e;
System.out.println(b == b2);
```

#### 4.4、原、反、补码

##### 4.4.1、原码

就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。

```java
 10的原码：0 0(23) 0000 1010
-10的原码：1 0(23) 0000 1010
```

##### 4.4.2、反码

- 正数的反码与其原码相同

- 负数的反码，在原码的基础上，保留符号位，其他位逐位取反


```java
 10的反码：	 跟10的原码相同       0 0(23) 0000 1010
-10的反码：	 拿到-10的原码， 		1 0(23) 0000 1010
		   保留符号位其他位取反   1 1(23) 1111 0101 
```

##### 4.4.3、补码

- 正数的补码与其原码相同

- 负数的补码是在其反码的末位加1


```java
 10的补码：	 跟10的原码相同       0 0(23) 0000 1010
-10的补码：	 拿到-10的反码， 		1 1(23) 1111 0101
			在反码基础上加1  	  1 1(23) 1111 0110 
```

=== 注意：负数的反码、补码与它的原码所表示的值不一样。

演示：

```java
模拟计算机底层进行运算：-10 + 10;
计算机底层通过补码进行运算，先获取-10补码：1 1(23) 1111 0110
    							   +
    				   再获取 10补码：0 0(23) 0000 1010
    							   =
    				   结果：		1【0 0(23) 0000 0000】
结果分析：两个int类型数据相加后结果值类型仍旧是int,其中int类型表示范围为4字节32个比特位，所以上述结果中第33位的那个1被自动抛弃，只保留低32位数值，0 0(23) 0000 0000，即 0。
所以：-10 + 10 == 0
```

=== 练习：写出-123的原反补码

```java
原码：1111 1011
反码：1000 0100
补码：1000 0101 // -5
```

##### 4.4.4、扩展

byte类型变量的取值范围是[-128，127]，char类型的取值范围是[0，65535]，请用二进制、原反补码推导出来（**理解即可，不用完全掌握推导过程**）

```java
//char取值范围推导过程
1.char类型只能表示0或正整数，其最高位不表示符号位
2.char类型占用2个字节，16个比特位
3.最小值 0000 0000 0000 0000 ->  0
4.最大值 1111 1111 1111 1111 ->  65535（大家可借助计算器，也可以手算）

//byte取值范围推导过程
1.byte类型可以表示正负整数和0
2.byte类型占用1个字节，8个比特位
3.8个比特位 1111 1111 能够表示的数字有 256个
4.最大值 0111 1111 -> 127
5.中间值 0000 0000 -> 0
6.其他值 8个bits能够表示256个数，其中[0,127]占用了128个，剩余的数都是小于0的，共128个，结果可推理出来为[-128,-1]
7.总结，表示范围[-128,127]
```

| 类型  | 字节  | 比特位 | 能否负值 |         取值范围         |
| :---: | :---: | :----: | :------: | :----------------------: |
| byte  | 1byte | 8bits  |    能    | [-128,127]  [-2^7,2^7-1] |
| short | 2byte | 16bits |    能    |      [-2^15,2^15-1]      |
| char  | 2byte | 16bits |    否    |  [0,65535]  [0,2^16-1]   |
|  int  | 4byte | 32bits |    能    |      [-2^31,2^31-1]      |
| long  | 8byte | 64bits |    能    |      [-2^63,2^63-1]      |

面试题1：

```java
// 类型转换面试题：下列代码是否存在错误，如果有，请指出说明，并改正
        byte b1 = 3;
        byte b2 = 4;
        byte b3 = b1 + b2;

        // 修改后：
        byte b1 = 3;
        byte b2 = 4;
        byte b3 = (byte) (b1+b2);
        System.out.println(b3);

        // Java存在常量优化机制：在编译的时候（javac）就会将3和4这两个字面量进行运算，产生的字节码文件：byte c = 7;
```

面试题2：

```java
public static void main(String[] args) {
	byte b1 = 126;
	byte b2 = (byte)(b1 + 3);
	
	//输出 -127，而非 129，建议用二进制补码运算验证结果
	System.out.println(b2);	
}
/* 
129 的二进制是：0000 0000 0000 0000 0000 0000 1000 0001（int 类型，32 位）
强制类型转换 (byte)129
将 int 强制转换为 byte，只保留低 8 位
129 的低 8 位是：1000 0001
这是 byte 类型的补码，我们需要还原它的十进制值：
    最高位是 1 → 负数
    补码 1000 0001 的原码是：
        先减 1 → 1000 0000
        再取反 → 0111 1111 = 127
    所以 1000 0001 表示的是 -127
*/
```

### 5、赋值运算符

#### 5.1、基本赋值运算符（=）

#### 5.2、扩展赋值运算符

![image-20250801223834456](D:\软件工程\Java\java-basic\day02\assets\image-20250801223834456.png)

=== 补充：扩展赋值运算符，内部自带强制转换。

### 6、关系运算符（比较运算符）

![image-20250801223936889](D:\软件工程\Java\java-basic\day02\assets\image-20250801223936889.png)

### 7、逻辑运算符

（1）用于连接boolean类型的表达式，或者是值

（2）整合多个条件，为一段整体的逻辑

| 符号 | 介绍     | 说明                    |
| ---- | -------- | ----------------------- |
| &    | 逻辑与   | 并且，遇false则false    |
| \|   | 逻辑或   | 或者，遇true则true      |
| !    | 逻辑非   | 取反                    |
| ^    | 逻辑异或 | 相同为false，不同为true |

短路逻辑运算符：

& ：没有短路效果，无论左边是true，false，右边都要执行

&& ：具有短路效果，左边为false，右边不执行；左边为true，右边要继续执行。

| ：没有短路效果，无论左边是true，false，右边都要执行

|| ：具有短路效果，左边为true，右边不执行；左边为false，右边要继续执行。

=== 常用逻辑运算符：&&、||、！（&&和||的执行效率更高）

### 8、三元运算符（三目）

#### 8.1、格式

判断条件？指1：指2；

#### 8.2、执行流程

首先计算判断条件的值；如果为true，值1就是结果；反之，值2为结果。

```java
public class OperatorDemo05 {
    /*
        三元运算符：
            判断条件?值1:值2
     */
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入你的年龄：");
        int age = sc.nextInt();
        System.out.println(age > 18 ? 0 : 1);// 0:允许；1:不允许
    }
}
```



### 9、运算符优先级

![image-20250801224956910](D:\软件工程\Java\java-basic\day02\assets\image-20250801224956910.png)